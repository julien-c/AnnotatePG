<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html lang="en"><head><title>
   What Made Lisp Different
  </title></head><body>
  <h1><span class="s s1">
   What Made Lisp Different
  </span></h1>
  <h2><span class="s s2">
   December 2001 (rev. May 2002)
   </span></h2><p align="justif"><span class="s s3">
    <i>
     (This article came about in response to some questions on
the
     <a target="_blank" href="http://ll1.mit.edu">
      LL1
     </a>
     mailing list.  It is now
incorporated in
     <a target="_blank" href="http://paulgraham.com/icad.html">
      Revenge of the Nerds
     </a>
     .)
    </i>
   </span></p>
   <p><span class="s s4">
    When McCarthy designed Lisp in the late 1950s, it was
a radical departure from existing languages,
the most important of which was
    <a target="_blank" href="http://paulgraham.com/history.html">
     Fortran
    </a>
    .</span>
   </p>
   <p><span class="s s6">
    Lisp embodied nine new ideas:
   </span></p>
   <p>
    </p><hr><b><span class="s s7">
      1. Conditionals.
     </span></b><span class="s s8">
     A conditional is an if-then-else
construct.  We take these for granted now.  They were
     </span><a target="_blank" href="http://www-formal.stanford.edu/jmc/history/lisp/node2.html"><span class="s s9">
      invented
     </span></a><span class="s s10">
     by McCarthy in the course of developing Lisp. 
(Fortran at that time only had a conditional
goto, closely based on the branch instruction in the 
underlying hardware.)  McCarthy, who was on the Algol committee, got
conditionals into Algol, whence they spread to most other
languages.
    
   
   </span><h3>
    <span class="s s11">2.</span> <span class="s s12">A function type.</span>
    <span class="s s13">In Lisp, functions are first class 
objects-- they're a data type just like integers, strings,
etc, and have a literal representation, can be stored in variables,
can be passed as arguments, and so on.</span>
   </h3>
  
  <h3><span class="s s15">
   3. Recursion.
   Recursion existed as a mathematical concept
before Lisp of course, but Lisp was the first programming language to support
it.  (It's arguably implicit in making functions first class
objects.)
   </span><h3><span class="s s16">
    4. A new concept of variables.
    In Lisp, all variables
are effectively pointers. Values are what
have types, not variables, and assigning or binding
variables means copying pointers, not what they point to.
    </span><h3><span class="s s17">
     5. Garbage-collection.
    </span></h3>
    <h3>
     <span class="s s18">6.</span> <span class="s s19">Programs composed of expressions.</span>
     <span class="s s20">Lisp programs are 
trees of expressions, each of which returns a value.</span>  
<span class="s s21">(In some Lisps expressions
can return multiple values.</span><span class="s s22">)  This is in contrast to Fortran
and most succeeding languages, which distinguish between
expressions and statements.</span>
     </h3></h3></h3><p>
      <span class="s s24">It was natural to have this
distinction in Fortran because (not surprisingly in a language
where the input format was punched cards) the language was
line-oriented.</span>  <span class="s s25">You could not nest statements.</span>  <span class="s s26">And
so while you needed expressions for math to work, there was
no point in making anything else return a value, because
there could not be anything waiting for it.</span>
     </p>
     <p>
      <span class="s s28">This limitation
went away with the arrival of block-structured languages,
but by then it was too late.</span> <span class="s s29">The distinction between
expressions and statements was entrenched.</span>  <span class="s s30">It spread from 
Fortran into Algol and thence to both their descendants.</span>
     </p>
     <p>
      <span class="s s32">When a language is made entirely of expressions, you can
compose expressions however you want.</span><span class="s s33">  You can say either
(using
      <a target="_blank" href="http://paulgraham.com/arc.html">
       Arc
      </a>
      syntax)
     </span></p>
     <p><span class="s s34">
      (if foo (= x 1) (= x 2))
     </span></p>
     <p><span class="s s35">
      or
     </span></p>
     <p><span class="s s36">
      (= x (if foo 1 2))
     </span></p>
     <h3><span class="s s37">
      7. A symbol type.
      Symbols differ from strings in that
you can test equality by comparing a pointer.
      </span><h3><span class="s s38">
       8. A notation for code
       using trees of symbols.
       </span><h3>
        <span class="s s39">9.</span> <span class="s s40">The whole language always available.</span>
        <span class="s s41">There is
no real distinction between read-time, compile-time, and runtime.</span>
<span class="s s42">You can compile or run code while reading, read or run code
while compiling, and read or compile code at runtime.</span>
        </h3></h3></h3><p>
         <span class="s s44">Running code at read-time lets users reprogram Lisp's syntax;
running code at compile-time is the basis of macros; compiling
at runtime is the basis of Lisp's use as an extension
language in programs like Emacs; and reading at runtime
enables programs to communicate using s-expressions, an
idea recently reinvented as XML.</span>
         </p><hr><p>
         <span class="s s46">When Lisp was first invented, all these ideas were far
removed from ordinary programming practice, which was
dictated largely by the hardware available in the late 1950s.</span>
        </p>
        <p>
         <span class="s s48">Over time, the default language, embodied
in a succession of popular languages, has
gradually evolved toward Lisp.</span>  <span class="s s49">1-5 are now widespread.</span>
<span class="s s50">6 is starting to appear in the mainstream.</span>
<span class="s s51">Python has a form of 7, though there doesn't seem to be
any syntax for it.</span>  
<span class="s s52">8, which (with 9) is what makes Lisp macros
possible, is so far still unique to Lisp,
perhaps because (a) it requires those parens, or something 
just as bad, and (b) if you add that final increment of power, 
you can no 
longer claim to have invented a new language, but only
to have designed a new dialect of Lisp ; -)</span>
        </p>
        <p>
         <span class="s s53">Though useful to present-day programmers, it's
strange to describe Lisp in terms of its
variation from the random expedients other languages
adopted.</span>  <span class="s s54">That was not, probably, how McCarthy
thought of it.</span><span class="s s55">  Lisp wasn't designed to fix the mistakes
in Fortran; it came about more as the byproduct of an
attempt to
         <a target="_blank" href="http://paulgraham.com/rootsoflisp.html">
          axiomatize computation
         </a>
         .</span>
        </p>
        <p>
         <!-- Nor is this a complete list of ideas that began with Lisp
and spread to other languages.  These are only the initial
set.  Several more were developed in successive Lisp
implementations, including continuations, 
multiple return values, rest parameters,
and assignment (setf) inversion. -->
        </p>
        <p><span class="s s57">
         This essay was originally published at
         <a target="_blank" href="http://www.paulgraham.com/diff.html?utm_source=pgebook">
          paulgraham.com
         </a>
         </span></p><p>
         </p>
        
       
      
     
    
   
  
 </body></html>
