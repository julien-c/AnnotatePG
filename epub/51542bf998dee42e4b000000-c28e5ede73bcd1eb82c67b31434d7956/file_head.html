<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<?xml version='1.0' encoding='utf-8'?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Holding a Program in One's Head</title></head><body>
  <h2><span class="s s1">Holding a Program in One's Head</span></h2>
<div><div><span class="s s2">August 2007A good programmer working intensively on his own code can hold it
in his mind the way a mathematician holds a problem he's working
on.</span> <span class="s s3">Mathematicians don't answer questions by working them out on
paper the way schoolchildren are taught to.</span> <span class="s s4">They do more in their
heads: they try to understand a problem space well enough that they
can walk around it the way you can walk around the memory of the
house you grew up in.</span> <span class="s s5">At its best programming is the same.</span> <span class="s s6">You
hold the whole program in your head, and you can manipulate it at
will.</span><span class="s s7">That's particularly valuable at the start of a project, because
initially the most important thing is to be able to change what
you're doing.</span> <span class="s s8">Not just to solve the problem in a different way,
but to change the problem you're solving.</span><span class="s s9">Your code is your understanding of the problem you're exploring.</span>
<span class="s s10">So it's only when you have your code in your head that you really
understand the problem.</span><span class="s s11">It's not easy to get a program into your head.</span> <span class="s s12">If you leave a
project for a few months, it can take days to really understand it
again when you return to it.</span> <span class="s s13">Even when you're actively working on
a program it can take half an hour to load into your head when you
start work each day.</span> <span class="s s14">And that's in the best case.</span> <span class="s s15">Ordinary
programmers working in typical office conditions never enter this
mode.</span> <span class="s s16">Or to put it more dramatically, ordinary programmers working
in typical office conditions never really understand the problems
they're solving.</span><span class="s s17">Even the best programmers don't always have the whole program they're
working on loaded into their heads.</span> <span class="s s18">But there are things you can
do to help: Avoid distractions.</span> <span class="s s19">Distractions are bad for many types of work,
 but especially bad for programming, because programmers tend to
 operate at the limit of the detail they can handle.</span><span class="s s20">The danger of a distraction depends not on how long it is, but
 on how much it scrambles your brain.</span> <span class="s s21">A programmer can leave the
 office and go and get a sandwich without losing the code in his
 head.</span> <span class="s s22">But the wrong kind of interruption can wipe your brain
 in 30 seconds.</span><span class="s s23">Oddly enough, scheduled distractions may be worse than unscheduled
 ones.</span> <span class="s s24">If you know you have a meeting in an hour, you don't even
 start working on something hard.</span> <span class="s s25">Work in long stretches.</span> <span class="s s26">Since there's a fixed cost each time
 you start working on a program, it's more efficient to work in
 a few long sessions than many short ones.</span> <span class="s s27">There will of course
 come a point where you get stupid because you're tired.</span> <span class="s s28">This
 varies from person to person.</span> <span class="s s29">I've heard of people hacking for
 36 hours straight, but the most I've ever been able to manage
 is about 18, and I work best in chunks of no more than 12.</span><span class="s s30">The optimum is not the limit you can physically endure.</span> <span class="s s31">There's
 an advantage as well as a cost of breaking up a project.</span> <span class="s s32">Sometimes
 when you return to a problem after a rest, you find your unconscious
 mind has left an answer waiting for you.</span> <span class="s s33">Use succinct languages.</span> <span class="s s34">More 
 powerful programming languages
 make programs shorter.</span> <span class="s s35">And programmers seem to think of programs
 at least partially in the language they're using to write them.</span>
 <span class="s s36">The more succinct the language, the shorter the program, and the
 easier it is to load and keep in your head.</span><span class="s s37">You can magnify the effect of a powerful language by using a
 style called bottom-up programming, where you write programs in
 multiple layers, the lower ones acting as programming languages
 for those above.</span> <span class="s s38">If you do this right, you only have to keep
 the topmost layer in your head.</span> <span class="s s39">Keep rewriting your program.</span> <span class="s s40">Rewriting a program often yields
 a cleaner design.</span> <span class="s s41">But it would have advantages even if it didn't:
 you have to understand a program completely to rewrite it, so
 there is no better way to get one loaded into your head.</span> <span class="s s42">Write rereadable code.</span> <span class="s s43">All programmers know it's good to write
 readable code.</span> <span class="s s44">But you yourself are the most important reader.</span>
 <span class="s s45">Especially in the beginning; a prototype is a conversation with
 yourself.</span> <span class="s s46">And when writing for yourself you have different
 priorities.</span> <span class="s s47">If you're writing for other people, you may not
 want to make code too dense.</span> <span class="s s48">Some parts of a program may be
 easiest to to read if you spread things out, like an introductory 
 textbook.</span> <span class="s s49">Whereas if you're writing code to make it easy to reload 
 into your head, it may be best to go for brevity.</span> <span class="s s50">Work in small groups.</span> <span class="s s51">When you manipulate a program in your
 head, your vision tends to stop at the edge of the code you own.</span>
 <span class="s s52">Other parts you don't understand as well, and more importantly,
 can't take liberties with.</span> <span class="s s53">So the smaller the number of
 programmers, the more completely a project can mutate.</span> <span class="s s54">If there's
 just one programmer, as there often is at first, you can do
 all-encompassing redesigns.</span> <span class="s s55">Don't have multiple people editing the same piece of code.</span> <span class="s s56">You
 never understand other people's code as well as your own.</span> <span class="s s57">No
 matter how thoroughly you've read it, you've only read it, not
 written it.</span> <span class="s s58">So if a piece of code is written by multiple authors,
 none of them understand it as well as a single author would.</span><span class="s s59">And of course you can't safely redesign something other people
 are working on.</span> <span class="s s60">It's not just that you'd have to ask permission.</span>
 <span class="s s61">You don't even let yourself think of such things.</span> <span class="s s62">Redesigning
 code with several authors is like changing laws; redesigning
 code you alone control is like seeing the other interpretation
 of an ambiguous image.</span><span class="s s63">If you want to put several people to work on a project, divide
 it into components and give each to one person.</span> <span class="s s64">Start small.</span> <span class="s s65">A program gets easier to hold in your head as you
 become familiar with it.</span> <span class="s s66">You can start to treat parts as black
 boxes once you feel confident you've fully explored them.</span> <span class="s s67">But
 when you first start working on a project, you're forced to see
 everything.</span> <span class="s s68">If you start with too big a problem, you may never
 quite be able to encompass it.</span> <span class="s s69">So if you need to write a big,
 complex program, the best way to begin may not be to write a
 spec for it, but to write a prototype that solves a subset of
 the problem.</span> <span class="s s70">Whatever the advantages of planning, they're often
 outweighed by the advantages of being able to keep a program in
 your head.</span>
<span class="s s71">It's striking how often programmers manage to hit all eight points
by accident.</span> <span class="s s72">Someone has an idea for a new project, but because
it's not officially sanctioned, he has to do it in off hours&acirc;&#128;&#148;which
turn out to be more productive because there are no distractions.</span>
<span class="s s73">Driven by his enthusiasm for the new project he works on it for
many hours at a stretch.</span> <span class="s s74">Because it's initially just an
experiment, instead of a "production" language he uses a mere
"scripting" language&acirc;&#128;&#148;which is in fact far more powerful.</span> <span class="s s75">He
completely rewrites the program several times; that wouldn't be
justifiable for an official project, but this is a labor of love
and he wants it to be perfect.</span> <span class="s s76">And since no one is going to see
it except him, he omits any comments except the note-to-self variety.</span>
<span class="s s77">He works in a small group perforce, because he either hasn't told
anyone else about the idea yet, or it seems so unpromising that no
one else is allowed to work on it.</span> <span class="s s78">Even if there is a group, they
couldn't have multiple people editing the same code, because it
changes too fast for that to be possible.</span> <span class="s s79">And the project starts
small because the idea is small at first; he just has some cool
hack he wants to try out.</span><span class="s s80">Even more striking are the number of officially sanctioned projects
that manage to do all eight things wrong.</span> <span class="s s81">In fact, if you look at
the way software gets written in most organizations, it's almost
as if they were deliberately trying to do things wrong.</span> <span class="s s82">In a sense,
they are.</span> <span class="s s83">One of the defining qualities of organizations since
there have been such a thing is to treat individuals as interchangeable
parts.</span> <span class="s s84">This works well for more parallelizable tasks, like fighting
wars.</span> <span class="s s85">For most of history a well-drilled army of professional
soldiers could be counted on to beat an army of individual warriors,
no matter how valorous.</span> <span class="s s86">But having ideas is not very parallelizable.</span>
<span class="s s87">And that's what programs are: ideas.</span><span class="s s88">It's not merely true that organizations dislike the idea of depending
on individual genius, it's a tautology.</span> <span class="s s89">It's part of the definition
of an organization not to.</span> <span class="s s90">Of our current concept of an organization,
at least.</span><span class="s s91">Maybe we could define a new kind of organization that combined the
efforts of individuals without requiring them to be interchangeable.</span>
<span class="s s92">Arguably a market is such a form of organization, though it may be
more accurate to describe a market as a degenerate case&acirc;&#128;&#148;as what
you get by default when organization isn't possible.</span><span class="s s93">Probably the best we'll do is some kind of hack, like making the
programming parts of an organization work differently from the rest.</span>
<span class="s s94">Perhaps the optimal solution is for big companies not even to try
to develop ideas in house, but simply to 
buy them.</span> <span class="s s95">But regardless
of what the solution turns out to be, the first step is to realize
there's a problem.</span> <span class="s s96">There is a contradiction in the very phrase
"software company.</span><span class="s s97">"</span> <span class="s s98">The two words are pulling in opposite directions.</span>
<span class="s s99">Any good programmer in a large organization is going to be at odds
with it, because organizations are designed to prevent what
programmers strive for.</span><span class="s s100">Good programmers manage to get a lot done anyway.</span> 
<span class="s s101">But often it
requires practically an act of rebellion against the organizations
that employ them.</span> <span class="s s102">Perhaps it will help if more people understand that the way
programmers behave is driven by the demands of the work they do.</span>
<span class="s s103">It's not because they're irresponsible that they work in long binges
during which they blow off all other obligations, plunge straight into
programming instead of writing specs first, and rewrite code that
already works.</span> <span class="s s104">It's not because they're unfriendly that they prefer
to work alone, or growl at people who pop their head in the door
to say hello.</span> <span class="s s105">This apparently random collection of annoying habits
has a single explanation: the power of holding a program in one's
head.</span><span class="s s106">Whether or not understanding this can help large organizations, it
can certainly help their competitors.</span> <span class="s s107">The weakest point in big
companies is that they don't let individual programmers do great
work.</span> <span class="s s108">So if you're a little startup, this is the place to attack
them.</span> <span class="s s109">Take on the kind of problems that have to be solved in one
big brain.</span><span class="s s110">Thanks to Sam Altman, David Greenspan, Aaron Iba, Jessica Livingston,
Robert Morris, Peter Norvig, Lisa Randall, Emmett Shear, Sergei Tsarev,
and Stephen Wolfram for reading drafts of this.</span></div></div>
  </body></html>
