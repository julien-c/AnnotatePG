<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<?xml version='1.0' encoding='utf-8'?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Five Questions about Language Design</title></head><body>
  <h2><span class="s s1">Five Questions about Language Design</span></h2>
<div><div><span class="s s2">May 2001
</span><p><span class="s s3">
(These are some notes I made
for a panel discussion on programming language design
at MIT on May 10, 2001.)</span></p>
<p><span class="s s4">
1. Programming Languages Are for People.
</span></p>
<p>
<span class="s s5">Programming languages
are how people talk to computers.</span> <span class="s s6">The computer would be just as
happy speaking any language that was unambiguous.</span> <span class="s s7">The reason we
have high level languages is because people can't deal with
machine language.</span> <span class="s s8">The point of programming
languages is to prevent our poor frail human brains from being 
overwhelmed by a mass of detail.</span></p>
<p><span class="s s9">Architects know that some kinds of design problems are more personal
than others.</span> <span class="s s10">One of the cleanest, most abstract design problems
is designing bridges.</span> <span class="s s11">There your job is largely a matter of spanning
a given distance with the least material.</span> <span class="s s12">The other end of the
spectrum is designing chairs.</span> <span class="s s13">Chair designers have to spend their
time thinking about human butts.</span></p>
<p><span class="s s14">Software varies in the same way.</span> <span class="s s15">Designing algorithms for routing
data through a network is a nice, abstract problem, like designing
bridges.</span> <span class="s s16">Whereas designing programming languages is like designing
chairs: it's all about dealing with human weaknesses.</span></p>
<p><span class="s s17">Most of us hate to acknowledge this.</span> <span class="s s18">Designing systems of great
mathematical elegance sounds a lot more appealing to most of us
than pandering to human weaknesses.</span> <span class="s s19">And there is a role for mathematical
elegance: some kinds of elegance make programs easier to understand.</span>
<span class="s s20">But elegance is not an end in itself.</span></p>
<p><span class="s s21">And when I say languages have to be designed to suit human weaknesses,
I don't mean that languages have to be designed for bad programmers.</span>
<span class="s s22">In fact I think you ought to design for the 
best programmers, but
even the best programmers have limitations.</span> <span class="s s23">I don't think anyone
would like programming in a language where all the variables were
the letter x with integer subscripts.</span>
</p>
<p><span class="s s25">
2. Design for Yourself and Your Friends.
</span></p>
<p>
<span class="s s26">If you look at the history of programming languages, a lot of the best
ones were languages designed for their own authors to use, and a
lot of the worst ones were designed for other people to use.</span></p>
<p><span class="s s27">When languages are designed for other people, it's always a specific
group of other people: people not as smart as the language designer.</span>
<span class="s s28">So you get a language that talks down to you.</span> <span class="s s29">Cobol is the most
extreme case, but a lot of languages are pervaded by this spirit.</span></p>
<p><span class="s s30">It has nothing to do with how abstract the language is.</span> <span class="s s31">C is pretty
low-level, but it was designed for its authors to use, and that's
why hackers like it.</span></p>
<p><span class="s s32">The argument for designing languages for bad programmers is that
there are more bad programmers than good programmers.</span> <span class="s s33">That may be
so.</span> <span class="s s34">But those few good programmers write a disproportionately
large percentage of the software.</span></p>
<p><span class="s s35">I'm interested in the question, how do you design a language that
the very best hackers will like?</span> <span class="s s36">I happen to think this is
identical to the question, how do you design a good programming
language?</span><span class="s s37">, but even if it isn't, it is at least an interesting
question.</span>
</p>
<p><span class="s s39">
3. Give the Programmer as Much Control as Possible.
</span></p>
<p>
<span class="s s40">Many languages
(especially the ones designed for other people) have the attitude
of a governess: they try to prevent you from
doing things that they think aren't good for you.</span> <span class="s s41">I like the 
opposite approach: give the programmer as much
control as you can.</span></p>
<p><span class="s s42">When I first learned Lisp, what I liked most about it was
that it considered me an equal partner.</span> <span class="s s43">In the other languages
I had learned up till then, there was the language and there was my 
program, written in the language, and the two were very separate.</span>
<span class="s s44">But in Lisp the functions and macros I wrote were just like those
that made up the language itself.</span> <span class="s s45">I could rewrite the language
if I wanted.</span> <span class="s s46">It had the same appeal as open-source software.</span></p>
<p><span class="s s47">
4. Aim for Brevity.
</span></p>
<p>
<span class="s s48">Brevity is underestimated and even scorned.</span>
<span class="s s49">But if you look into the hearts of hackers, you'll see that they
really love it.</span> <span class="s s50">How many times have you heard hackers speak fondly
of how in, say, APL, they could do amazing things with just a couple
lines of code?</span> <span class="s s51">I think anything that really smart people really
love is worth paying attention to.</span></p>
<p><span class="s s52">I think almost anything
you can do to make programs shorter is good.</span> <span class="s s53">There should be lots
of library functions; anything that can be implicit should be;
the syntax should be terse to a fault; even the names of things
should be short.</span></p>
<p><span class="s s54">And it's not only programs that should be short.</span> <span class="s s55">The manual should
be thin as well.</span> <span class="s s56">A good part of manuals is taken up with clarifications
and reservations and warnings and special cases.</span> <span class="s s57">If you force 
yourself to shorten the manual, in the best case you do it by fixing
the things in the language that required so much explanation.</span></p>
<p><span class="s s58">
5. Admit What Hacking Is.
</span></p>
<p>
<span class="s s59">A lot of people wish that hacking was
mathematics, or at least something like a natural science.</span> <span class="s s60">I think
hacking is more like architecture.</span> <span class="s s61">Architecture is
related to physics, in the sense that architects have to design
buildings that don't fall down, but the actual goal of architects
is to make great buildings, not to make discoveries about statics.</span></p>
<p><span class="s s62">What hackers like to do is make great programs.
And I think, at least in our own minds, we have to remember that it's
an admirable thing to write great programs, even when this work 
doesn't translate easily into the conventional intellectual
currency of research papers.</span> <span class="s s63">Intellectually, it is just as
worthwhile to design a language programmers will love as it is to design a
horrible one that embodies some idea you can publish a paper
about.</span></p>
<p><span class="s s64">
1. How to Organize Big Libraries?
</span></p>
<p>
<span class="s s65">Libraries are becoming an
increasingly important component of programming languages.</span> <span class="s s66">They're
also getting bigger, and this can be dangerous.</span> <span class="s s67">If it takes longer
to find the library function that will do what you want than it
would take to write it yourself, then all that code is doing nothing
but make your manual thick.</span> <span class="s s68">(The Symbolics manuals were a case in 
point.</span><span class="s s69">) So I think we will have to work on ways to organize
libraries.</span> <span class="s s70">The ideal would be to design them so that the programmer
could guess what library call would do the right thing.</span></p>
<p><span class="s s71">
2. Are People Really Scared of Prefix Syntax?
</span></p>
<p>
<span class="s s72">This is an open
problem in the sense that I have wondered about it for years and
still don't know the answer.</span> <span class="s s73">Prefix syntax seems perfectly natural
to me, except possibly for math.</span> <span class="s s74">But it could be that a lot of 
Lisp's unpopularity is simply due to having an unfamiliar syntax.</span> 
<span class="s s75">Whether to do anything about it, if it is true, is another question.</span> 
</p>
<p><span class="s s77">
3. What Do You Need for Server-Based Software?
</span></p>
<p>
<span class="s s78">I think a lot of the most exciting new applications that get written
in the next twenty years will be Web-based applications, meaning
programs that sit on the server and talk to you through a Web
browser.</span> <span class="s s79">And to write these kinds of programs we may need some
new things.</span></p>
<p><span class="s s80">One thing we'll need is support for the new way that server-based 
apps get released.</span> <span class="s s81">Instead of having one or two big releases a
year, like desktop software, server-based apps get released as a
series of small changes.</span> <span class="s s82">You may have as many as five or ten
releases a day.</span> <span class="s s83">And as a rule everyone will always use the latest
version.</span></p>
<p><span class="s s84">You know how you can design programs to be debuggable?</span>
<span class="s s85">Well, server-based software likewise has to be designed to be
changeable.</span> <span class="s s86">You have to be able to change it easily, or at least
to know what is a small change and what is a momentous one.</span></p>
<p><span class="s s87">Another thing that might turn out to be useful for server based
software, surprisingly, is continuations.</span> <span class="s s88">In Web-based software
you can use something like continuation-passing style to get the
effect of subroutines in the inherently 
stateless world of a Web
session.</span> <span class="s s89">Maybe it would be worthwhile having actual continuations,
if it was not too expensive.</span></p>
<p><span class="s s90">
4. What New Abstractions Are Left to Discover?
</span></p>
<p>
<span class="s s91">I'm not sure how
reasonable a hope this is, but one thing I would really love to 
do, personally, is discover a new abstraction-- something that would
make as much of a difference as having first class functions or
recursion or even keyword parameters.</span> <span class="s s92">This may be an impossible
dream.</span> <span class="s s93">These things don't get discovered that often.</span> <span class="s s94">But I am always
looking.</span></p>
<p><span class="s s95">
1. You Can Use Whatever Language You Want.
</span></p>
<p>
<span class="s s96">Writing application
programs used to mean writing desktop software.</span> <span class="s s97">And in desktop
software there is a big bias toward writing the application in the
same language as the operating system.</span> <span class="s s98">And so ten years ago,
writing software pretty much meant writing software in C.</span>
<span class="s s99">Eventually a tradition evolved:
application programs must not be written in unusual languages.</span> 
<span class="s s100">And this tradition had so long to develop that nontechnical people
like managers and venture capitalists also learned it.</span></p>
<p><span class="s s101">Server-based software blows away this whole model.</span> <span class="s s102">With server-based
software you can use any language you want.</span> <span class="s s103">Almost nobody understands
this yet (especially not managers and venture capitalists).</span>
<span class="s s104">A few hackers understand it, and that's why we even hear
about new, indy languages like Perl and Python.</span> <span class="s s105">We're not hearing
about Perl and Python because people are using them to write Windows
apps.</span></p>
<p><span class="s s106">What this means for us, as people interested in designing programming
languages, is that there is now potentially an actual audience for
our work.</span></p>
<p><span class="s s107">
2. Speed Comes from Profilers.
</span></p>
<p>
<span class="s s108">Language designers, or at least
language implementors, like to write compilers that generate fast
code.</span> <span class="s s109">But I don't think this is what makes languages fast for users.</span>
<span class="s s110">Knuth pointed out long ago that speed only matters in a few critical
bottlenecks.</span> <span class="s s111">And anyone who's tried it knows that you can't guess
where these bottlenecks are.</span> <span class="s s112">Profilers are the answer.</span></p>
<p><span class="s s113">Language designers are solving the wrong problem.</span> <span class="s s114">Users don't need
benchmarks to run fast.</span> <span class="s s115">What they need is a language that can show
them what parts of their own programs need to be rewritten.</span> <span class="s s116">That's
where speed comes from in practice.</span> <span class="s s117">So maybe it would be a net 
win if language implementors took half the time they would
have spent doing compiler optimizations and spent it writing a
good profiler instead.</span></p>
<p><span class="s s118">
3. You Need an Application to Drive the Design of a Language.
</span></p>
<p>
<span class="s s119">This may not be an absolute rule, but it seems like the best languages
all evolved together with some application they were being used to
write.</span> <span class="s s120">C was written by people who needed it for systems programming.</span>
<span class="s s121">Lisp was developed partly to do symbolic differentiation, and
McCarthy was so eager to get started that he was writing differentiation
programs even in the first paper on Lisp, in 1960.</span></p>
<p><span class="s s122">It's especially good if your application solves some new problem.</span>
<span class="s s123">That will tend to drive your language to have new features that 
programmers need.</span> <span class="s s124">I personally am interested in writing
a language that will be good for writing server-based applications.</span></p>
<p><span class="s s125">[During the panel, Guy Steele also made this point, with the
additional suggestion that the application should not consist of
writing the compiler for your language, unless your language
happens to be intended for writing compilers.</span><span class="s s126">]</span>
</p>
<p><span class="s s127">
4. A Language Has to Be Good for Writing Throwaway Programs.
</span></p>
<p>
<span class="s s128">You know what a throwaway program is: something you write quickly for
some limited task.</span> <span class="s s129">I think if you looked around you'd find that 
a lot of big, serious programs started as throwaway programs. I
would not be surprised if most programs started as throwaway
programs. And so if you want to make a language that's good for
writing software in general, it has to be good for writing throwaway
programs, because that is the larval stage of most software.</span></p>
<p><span class="s s130">
5. Syntax Is Connected to Semantics.
</span></p>
<p>
<span class="s s131">It's traditional to think of
syntax and semantics as being completely separate.</span> <span class="s s132">This will
sound shocking, but it may be that they aren't.</span>
<span class="s s133">I think that what you want in your language may be related
to how you express it.</span></p>
<p><span class="s s134">I was talking recently to Robert Morris, and he pointed out that
operator overloading is a bigger win in languages with infix
syntax.</span> <span class="s s135">In a language with prefix syntax, any function you define
is effectively an operator.</span> <span class="s s136">If you want to define a plus for a
new type of number you've made up, you can just define a new function
to add them.</span> <span class="s s137">If you do that in a language with infix syntax,
there's a big difference in appearance between the use of an
overloaded operator and a function call.</span></p>
<p><span class="s s138">
1. New Programming Languages.
</span></p>
<p>
<span class="s s139">Back in the 1970s
it was fashionable to design new programming languages.</span> <span class="s s140">Recently
it hasn't been.</span> <span class="s s141">But I think server-based software will make new 
languages fashionable again.</span> <span class="s s142">With server-based software, you can
use any language you want, so if someone does design a language that
actually seems better than others that are available, there will be
people who take a risk and use it.</span></p>
<p><span class="s s143">
2. Time-Sharing.
</span></p>
<p>
<span class="s s144">Richard Kelsey gave this as an idea whose time
has come again in the last panel, and I completely agree with him.</span>
<span class="s s145">My guess (and Microsoft's guess, it seems) is that much computing
will move from the desktop onto remote servers.</span> <span class="s s146">In other words, 
time-sharing is back.</span> <span class="s s147">And I think there will need to be support
for it at the language level.</span> <span class="s s148">For example, I know that Richard
and Jonathan Rees have done a lot of work implementing process 
scheduling within Scheme 48.</span></p>
<p><span class="s s149">
3. Efficiency.
</span></p>
<p>
<span class="s s150">Recently it was starting to seem that computers
were finally fast enough.</span> <span class="s s151">More and more we were starting to hear
about byte code, which implies to me at least that we feel we have
cycles to spare.</span> <span class="s s152">But I don't think we will, with server-based
software.</span> <span class="s s153">Someone is going to have to pay for the servers that
the software runs on, and the number of users they can support per
machine will be the divisor of their capital cost.</span></p>
<p><span class="s s154">So I think efficiency will matter, at least in computational
bottlenecks.</span> <span class="s s155">It will be especially important to do i/o fast,
because server-based applications do a lot of i/o.</span></p>
<p><span class="s s156">It may turn out that byte code is not a win, in the end.</span> <span class="s s157">Sun and
Microsoft seem to be facing off in a kind of a battle of the byte
codes at the moment.</span> <span class="s s158">But they're doing it because byte code is a
convenient place to insert themselves into the process, not because
byte code is in itself a good idea.</span> <span class="s s159">It may turn out that this
whole battleground gets bypassed.</span> <span class="s s160">That would be kind of amusing.</span></p>
<p><span class="s s161">
1. Clients.
</span></p>
<p>
<span class="s s162">This is just a guess, but my guess is that
the winning model for most applications will be purely server-based.</span>
<span class="s s163">Designing software that works on the assumption that everyone will 
have your client is like designing a society on the assumption that
everyone will just be honest.</span> <span class="s s164">It would certainly be convenient, but
you have to assume it will never happen.</span></p>
<p><span class="s s165">I think there will be a proliferation of devices that have some
kind of Web access, and all you'll be able to assume about them is
that they can support simple html and forms. Will you have a
browser on your cell phone?</span> <span class="s s166">Will there be a phone in your palm 
pilot?</span> <span class="s s167">Will your blackberry get a bigger screen?</span> <span class="s s168">Will you be able
to browse the Web on your gameboy?</span> <span class="s s169">Your watch?</span> <span class="s s170">I don't know.</span> 
<span class="s s171">And I don't have to know if I bet on
everything just being on the server.</span> <span class="s s172">It's
just so much more robust to have all the 
brains on the server.</span>
</p>
<p><span class="s s174">
2. Object-Oriented Programming.
</span></p>
<p>
<span class="s s175">I realize this is a
controversial one, but I don't think object-oriented programming
is such a big deal.</span> <span class="s s176">I think it is a fine model for certain kinds
of applications that need that specific kind of data structure, 
like window systems, simulations, and cad programs. But I don't
see why it ought to be the model for all programming.</span></p>
<p><span class="s s177">I think part of the reason people in big companies like object-oriented
programming is because it yields a lot of what looks like work.</span>
<span class="s s178">Something that might naturally be represented as, say, a list of
integers, can now be represented as a class with all kinds of
scaffolding and hustle and bustle.</span></p>
<p><span class="s s179">Another attraction of
object-oriented programming is that methods give you some of the
effect of first class functions.</span> <span class="s s180">But this is old news to Lisp
programmers.</span> <span class="s s181">When you have actual first class functions, you can
just use them in whatever way is appropriate to the task at hand,
instead of forcing everything into a mold of classes and methods.</span></p>
<p><span class="s s182">What this means for language design, I think, is that you shouldn't
build object-oriented programming in too deeply.</span> <span class="s s183">Maybe the
answer is to offer more general, underlying stuff, and let people design
whatever object systems they want as libraries.</span>
</p>
<p><span class="s s185">
3. Design by Committee.
</span></p>
<p>
<span class="s s186">Having your language designed by a committee is a big pitfall, 
and not just for the reasons everyone knows about.</span> <span class="s s187">Everyone
knows that committees tend to yield lumpy, inconsistent designs.</span> 
<span class="s s188">But I think a greater danger is that they won't take risks.</span>
<span class="s s189">When one person is in charge he can take risks
that a committee would never agree on.</span></p>
<p><span class="s s190">Is it necessary to take risks to design a good language though?</span>
<span class="s s191">Many people might suspect
that language design is something where you should stick fairly
close to the conventional wisdom.</span> <span class="s s192">I bet this isn't true.</span>
<span class="s s193">In everything else people do, reward is proportionate to risk.</span>
<span class="s s194">Why should language design be any different?</span></p>
</div></div>
  </body></html>
