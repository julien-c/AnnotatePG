<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<?xml version='1.0' encoding='utf-8'?><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Being Popular</title></head><body>
  <h2><span class="s s1">Being Popular</span></h2>
<div><div>
<p><span class="s s2">May 2001</span></p>
<p><span class="s s3">(This article was written as a kind of business plan for a
new language.</span>
<span class="s s4">So it is missing (because it takes for granted) the most important
feature of a good programming language: very powerful abstractions.</span><span class="s s5">)</span></p>
<p><span class="s s6">A friend of mine once told an eminent operating systems
expert that he wanted to design a really good
programming language.</span> <span class="s s7">The expert told him that it would be a
waste of time, that programming languages don't become popular
or unpopular based on their merits, and so no matter how
good his language was, no one would use it.</span> <span class="s s8">At least, that
was what had happened to the language he had designed.</span></p>
<p><span class="s s9">What does make a language popular?</span> <span class="s s10">Do popular
languages deserve their popularity?</span> <span class="s s11">Is it worth trying to
define a good programming language?</span> <span class="s s12">How would you do it?</span></p>
<p><span class="s s13">I think the answers to these questions can be found by looking 
at hackers, and learning what they want.</span> <span class="s s14">Programming
languages are for hackers, and a programming language
is good as a programming language (rather than, say, an
exercise in denotational semantics or compiler design)
if and only if hackers like it.</span></p>
<p><span class="s s15">1 The Mechanics of Popularity</span></p>
<p><span class="s s16">It's true, certainly, that most people don't choose programming
languages simply based on their merits.</span> <span class="s s17">Most programmers are told
what language to use by someone else.</span> <span class="s s18">And yet I think the effect
of such external factors on the popularity of programming languages
is not as great as it's sometimes thought to be.</span> <span class="s s19">I think a bigger
problem is that a hacker's idea of a good programming language is
not the same as most language designers'.</span></p>
<p><span class="s s20">Between the two, the hacker's opinion is the one that matters.</span>
<span class="s s21">Programming languages are not theorems. They're tools, designed
for people, and they have to be designed to suit human strengths
and weaknesses as much as shoes have to be designed for human feet.</span>
<span class="s s22">If a shoe pinches when you put it on, it's a bad shoe, however
elegant it may be as a piece of sculpture.</span></p>
<p><span class="s s23">It may be that the majority of programmers can't tell a good language
from a bad one.</span> <span class="s s24">But that's no different with any other tool.</span> <span class="s s25">It
doesn't mean that it's a waste of time to try designing a good
language.</span> <span class="s s26">Expert hackers 
can tell a good language when they see
one, and they'll use it.</span> <span class="s s27">Expert hackers are a tiny minority,
admittedly, but that tiny minority write all the good software,
and their influence is such that the rest of the programmers will
tend to use whatever language they use.</span> <span class="s s28">Often, indeed, it is not
merely influence but command: often the expert hackers are the very
people who, as their bosses or faculty advisors, tell the other
programmers what language to use.</span></p>
<p><span class="s s29">The opinion of expert hackers is not the only force that determines
the relative popularity of programming languages-- legacy software
(Cobol) and hype (Ada, Java) also play a role-- but I think it is
the most powerful force over the long term.</span> <span class="s s30">Given an initial critical
mass and enough time, a programming language probably becomes about
as popular as it deserves to be.</span> <span class="s s31">And popularity further separates
good languages from bad ones, because feedback from real live users
always leads to improvements.</span> <span class="s s32">Look at how much any popular language
has changed during its life.</span> <span class="s s33">Perl and Fortran are extreme cases,
but even Lisp has changed a lot.</span> <span class="s s34">Lisp 1.</span><span class="s s35">5 didn't have macros, for
example; these evolved later, after hackers at MIT had spent a
couple years using Lisp to write real programs. [1]</span></p>
<p><span class="s s36">So whether or not a language has to be good to be popular, I think
a language has to be popular to be good.</span> <span class="s s37">And it has to stay popular
to stay good.</span> <span class="s s38">The state of the art in programming languages doesn't
stand still.</span> <span class="s s39">And yet the Lisps we have today are still pretty much
what they had at MIT in the mid-1980s, because that's the last time
Lisp had a sufficiently large and demanding user base.</span></p>
<p><span class="s s40">Of course, hackers have to know about a language before they can
use it.</span> <span class="s s41">How are they to hear?</span> <span class="s s42">From other hackers.</span> <span class="s s43">But there has to
be some initial group of hackers using the language for others even
to hear about it.</span> <span class="s s44">I wonder how large this group has to be; how many
users make a critical mass?</span> <span class="s s45">Off the top of my head, I'd say twenty.</span>
<span class="s s46">If a language had twenty separate users, meaning twenty users who
decided on their own to use it, I'd consider it to be real.</span></p>
<p><span class="s s47">Getting there can't be easy.</span> <span class="s s48">I would not be surprised if it is
harder to get from zero to twenty than from twenty to a thousand.</span>
<span class="s s49">The best way to get those initial twenty users is probably to use
a trojan horse: to give people an application they want, which
happens to be written in the new language.</span></p>
<p><span class="s s50">2 External Factors</span></p>
<p><span class="s s51">Let's start by acknowledging one external factor that does affect
the popularity of a programming language.</span> <span class="s s52">To become popular, a
programming language has to be the scripting language of a popular
system.</span> <span class="s s53">Fortran and Cobol were the scripting languages of early
IBM mainframes.</span> <span class="s s54">C was the scripting language of Unix, and so, later,
was Perl.</span> <span class="s s55">Tcl is the scripting language of Tk.</span> <span class="s s56">Java and Javascript
are intended to be the scripting languages of web browsers.</span></p>
<p><span class="s s57">Lisp is not a massively popular language because it is not the
scripting language of a massively popular system.</span> <span class="s s58">What popularity
it retains dates back to the 1960s and 1970s, when it was the
scripting language of MIT.</span> <span class="s s59">A lot of the great programmers of the
day were associated with MIT at some point.</span> <span class="s s60">And in the early 1970s,
before C, MIT's dialect of Lisp, called MacLisp, was one of the
only programming languages a serious hacker would want to use.</span></p>
<p><span class="s s61">Today Lisp is the scripting language of two moderately popular
systems, Emacs and Autocad, and for that reason I suspect that most
of the Lisp programming done today is done in Emacs Lisp or AutoLisp.</span></p>
<p><span class="s s62">Programming languages don't exist in isolation.</span> <span class="s s63">To hack is a
transitive verb-- hackers are usually hacking something-- and in
practice languages are judged relative to whatever they're used to
hack.</span> <span class="s s64">So if you want to design a popular language, you either have
to supply more than a language, or you have to design your language
to replace the scripting language of some existing system.</span></p>
<p><span class="s s65">Common Lisp is unpopular partly because it's an orphan.</span> <span class="s s66">It did
originally come with a system to hack: the Lisp Machine.</span> <span class="s s67">But Lisp
Machines (along with parallel computers) were steamrollered by the
increasing power of general purpose processors in the 1980s.</span> <span class="s s68">Common
Lisp might have remained popular if it had been a good scripting
language for Unix.</span> <span class="s s69">It is, alas, an atrociously bad one.</span></p>
<p><span class="s s70">One way to describe this situation is to say that a language isn't
judged on its own merits.</span> <span class="s s71">Another view is that a programming language
really isn't a programming language unless it's also the scripting
language of something.</span> <span class="s s72">This only seems unfair if it comes as a
surprise.</span> <span class="s s73">I think it's no more unfair than expecting a programming
language to have, say, an implementation.</span> <span class="s s74">It's just part of what
a programming language is.</span></p>
<p><span class="s s75">A programming language does need a good implementation, of course,
and this must be free.</span> <span class="s s76">Companies will pay for software, but individual
hackers won't, and it's the hackers you need to attract.</span></p>
<p><span class="s s77">A language also needs to have a book about it.</span> <span class="s s78">The book should be
thin, well-written, and full of good examples.</span> <span class="s s79"></span> <span class="s s80">At the moment I'd almost say that a language has to have a
book published by O'Reilly.</span> <span class="s s81">That's becoming the test of mattering
to hackers.</span></p>
<p><span class="s s82">There should be online documentation as well.</span> <span class="s s83">In fact, the book
can start as online documentation.</span> <span class="s s84">But I don't think that physical
books are outmoded yet.</span> <span class="s s85">Their format is convenient, and the de
facto censorship imposed by publishers is a useful if imperfect
filter.</span> <span class="s s86">Bookstores are one of the most important places for learning
about new languages.</span></p>
<p><span class="s s87">3 Brevity</span></p>
<p><span class="s s88">Given that you can supply the three things any language needs-- a
free implementation, a book, and something to hack-- how do you
make a language that hackers will like?</span></p>
<p><span class="s s89">One thing hackers like is brevity.</span> <span class="s s90">Hackers are lazy, in the same
way that mathematicians and modernist architects are lazy: they
hate anything extraneous.</span> <span class="s s91">It would not be far from the truth to
say that a hacker about to write a program decides what language
to use, at least subconsciously, based on the total number of
characters he'll have to type.</span> <span class="s s92">If this isn't precisely how hackers
think, a language designer would do well to act as if it were.</span></p>
<p><span class="s s93">It is a mistake to try to baby the user with long-winded expressions
that are meant to resemble English.</span> <span class="s s94">Cobol is notorious for this
flaw.</span> <span class="s s95">A hacker would consider being asked to write</span></p>
<p><span class="s s96">add x to y giving z</span></p>
<p><span class="s s97">instead of</span></p>
<p><span class="s s98">z = x+y</span></p>
<p><span class="s s99">as something between an insult to his intelligence and a sin against
God.</span></p>
<p><span class="s s100">It has sometimes been said that Lisp should use first and rest
instead of car and cdr, because it would make programs easier to
read.</span> <span class="s s101">Maybe for the first couple hours.</span> <span class="s s102">But a hacker can learn
quickly enough that car means the first element of a list and cdr
means the rest.</span> <span class="s s103">Using first and rest means 50% more typing.</span> <span class="s s104">And
they are also different lengths, meaning that the arguments won't
line up when they're called, as car and cdr often are, in successive
lines.</span> <span class="s s105">I've found that it matters a lot how code lines up on the
page.</span> <span class="s s106">I can barely read Lisp code when it is set in a variable-width
font, and friends say this is true for other languages too.</span></p>
<p><span class="s s107">Brevity is one place where strongly typed languages lose.</span> <span class="s s108">All other
things being equal, no one wants to begin a program with a bunch
of declarations.</span> <span class="s s109">Anything that can be implicit, should be.</span></p>
<p><span class="s s110">The individual tokens should be short as well.</span> <span class="s s111">Perl and Common Lisp
occupy opposite poles on this question.</span> <span class="s s112">Perl programs can be almost
cryptically dense, while the names of built-in Common Lisp operators
are comically long.</span> <span class="s s113">The designers of Common Lisp probably expected
users to have text editors that would type these long names for
them.</span> <span class="s s114">But the cost of a long name is not just the cost of typing
it.</span> <span class="s s115">There is also the cost of reading it, and the cost of the space
it takes up on your screen.</span></p>
<p><span class="s s116">4 Hackability</span></p>
<p><span class="s s117">There is one thing more important than brevity to a hacker: being
able to do what you want.</span> <span class="s s118">In the history of programming languages
a surprising amount of effort has gone into preventing programmers
from doing things considered to be improper.</span> <span class="s s119">This is a dangerously
presumptuous plan.</span> <span class="s s120">How can the language designer know what the
programmer is going to need to do?</span> <span class="s s121">I think language designers would
do better to consider their target user to be a genius who will
need to do things they never anticipated, rather than a bumbler
who needs to be protected from himself.</span> <span class="s s122">The bumbler will shoot
himself in the foot anyway.</span> <span class="s s123">You may save him from referring to
variables in another package, but you can't save him from writing
a badly designed program to solve the wrong problem, and taking
forever to do it.</span></p>
<p><span class="s s124">Good programmers often want to do dangerous and unsavory things.</span>
<span class="s s125">By unsavory I mean things that go behind whatever semantic facade
the language is trying to present: getting hold of the internal
representation of some high-level abstraction, for example.</span> <span class="s s126">Hackers
like to hack, and hacking means getting inside things and second
guessing the original designer.</span></p>
<p><span class="s s127">Let yourself be second guessed.</span> <span class="s s128">When you make any tool, people use
it in ways you didn't intend, and this is especially true of a
highly articulated tool like a programming language.</span> <span class="s s129">Many a hacker
will want to tweak your semantic model in a way that you never
imagined.</span> <span class="s s130">I say, let them; give the programmer access to as much
internal stuff as you can without endangering runtime systems like
the garbage collector.</span></p>
<p><span class="s s131">In Common Lisp I have often wanted to iterate through the fields
of a struct-- to comb out references to a deleted object, for example,
or find fields that are uninitialized.</span> <span class="s s132">I know the structs are just
vectors underneath.</span> <span class="s s133">And yet I can't write a general purpose function
that I can call on any struct.</span> <span class="s s134">I can only access the fields by
name, because that's what a struct is supposed to mean.</span></p>
<p><span class="s s135">A hacker may only want to subvert the intended model of things once
or twice in a big program.</span> <span class="s s136">But what a difference it makes to be
able to.</span> <span class="s s137">And it may be more than a question of just solving a
problem.</span> <span class="s s138">There is a kind of pleasure here too.</span> <span class="s s139">Hackers share the
surgeon's secret pleasure in poking about in gross innards, the
teenager's secret pleasure in popping zits.</span> <span class="s s140">[2] For boys, at least,
certain kinds of horrors are fascinating.</span> <span class="s s141">Maxim magazine publishes
an annual volume of photographs, containing a mix of pin-ups and
grisly accidents.</span> <span class="s s142">They know their audience.</span></p>
<p><span class="s s143">Historically, Lisp has been good at letting hackers have their way.</span>
<span class="s s144">The political correctness of Common Lisp is an aberration.</span> <span class="s s145">Early
Lisps let you get your hands on everything.</span> <span class="s s146">A good deal of that
spirit is, fortunately, preserved in macros.</span> <span class="s s147">What a wonderful thing,
to be able to make arbitrary transformations on the source code.</span></p>
<p><span class="s s148">Classic macros are a real hacker's tool-- simple, powerful, and
dangerous.</span> <span class="s s149">It's so easy to understand what they do: you call a
function on the macro's arguments, and whatever it returns gets
inserted in place of the macro call.</span> <span class="s s150">Hygienic macros embody the
opposite principle.</span> <span class="s s151">They try to protect you from understanding what
they're doing.</span> <span class="s s152">I have never heard hygienic macros explained in one
sentence.</span> <span class="s s153">And they are a classic example of the dangers of deciding
what programmers are allowed to want.</span> <span class="s s154">Hygienic macros are intended
to protect me from variable capture, among other things, but variable
capture is exactly what I want in some macros.</span></p>
<p><span class="s s155">A really good language should be both clean and dirty: cleanly
designed, with a small core of well understood and highly orthogonal
operators, but dirty in the sense that it lets hackers have their
way with it.</span> <span class="s s156">C is like this.</span> <span class="s s157">So were the early Lisps.</span> <span class="s s158">A real hacker's
language will always have a slightly raffish character.</span></p>
<p><span class="s s159">A good programming language should have features that make the kind
of people who use the phrase "software engineering" shake their
heads disapprovingly.</span> <span class="s s160">At the other end of the continuum are languages
like Ada and Pascal, models of propriety that are good for teaching
and not much else.</span></p>
<p><span class="s s161">5 Throwaway Programs</span></p>
<p><span class="s s162">To be attractive to hackers, a language must be good for writing
the kinds of programs they want to write.</span> <span class="s s163">And that means, perhaps
surprisingly, that it has to be good for writing throwaway programs.</span></p>
<p><span class="s s164">A throwaway program is a program you write quickly for some limited
task: a program to automate some system administration task, or
generate test data for a simulation, or convert data from one format
to another.</span> <span class="s s165">The surprising thing about throwaway programs is that,
like the "temporary" buildings built at so many American universities
during World War II, they often don't get thrown away.</span> <span class="s s166">Many evolve
into real programs, with real features and real users.</span></p>
<p><span class="s s167">I have a hunch that the best big programs begin life this way,
rather than being designed big from the start, like the Hoover Dam.</span>
<span class="s s168">It's terrifying to build something big from scratch.</span> <span class="s s169">When people
take on a project that's too big, they become overwhelmed.</span> <span class="s s170">The
project either gets bogged down, or the result is sterile and
wooden: a shopping mall rather than a real downtown, Brasilia rather
than Rome, Ada rather than C.</span></p>
<p><span class="s s171">Another way to get a big program is to start with a throwaway
program and keep improving it.</span> <span class="s s172">This approach is less daunting, and
the design of the program benefits from evolution.</span> <span class="s s173">I think, if one
looked, that this would turn out to be the way most big programs
were developed.</span> <span class="s s174">And those that did evolve this way are probably
still written in whatever language they were first written in,
because it's rare for a program to be ported, except for political
reasons.</span> <span class="s s175">And so, paradoxically, if you want to make a language that
is used for big systems, you have to make it good for writing
throwaway programs, because that's where big systems come from.</span></p>
<p><span class="s s176">Perl is a striking example of this idea.</span> <span class="s s177">It was not only designed
for writing throwaway programs, but was pretty much a throwaway
program itself.</span> <span class="s s178">Perl began life as a collection of utilities for
generating reports, and only evolved into a programming language
as the throwaway programs people wrote in it grew larger.</span> <span class="s s179">It was
not until Perl 5 (if then) that the language was suitable for
writing serious programs, and yet it was already massively popular.</span></p>
<p><span class="s s180">What makes a language good for throwaway programs?</span> <span class="s s181">To start with,
it must be readily available.</span> <span class="s s182">A throwaway program is something that
you expect to write in an hour.</span> <span class="s s183">So the language probably must
already be installed on the computer you're using.</span> <span class="s s184">It can't be
something you have to install before you use it.</span> <span class="s s185">It has to be there.</span>
<span class="s s186">C was there because it came with the operating system.</span> <span class="s s187">Perl was
there because it was originally a tool for system administrators,
and yours had already installed it.</span></p>
<p><span class="s s188">Being available means more than being installed, though.</span> <span class="s s189">An
interactive language, with a command-line interface, is more
available than one that you have to compile and run separately.</span> <span class="s s190">A
popular programming language should be interactive, and start up
fast.</span></p>
<p><span class="s s191">Another thing you want in a throwaway program is brevity.</span> <span class="s s192">Brevity
is always attractive to hackers, and never more so than in a program
they expect to turn out in an hour.</span></p>
<p><span class="s s193">6 Libraries</span></p>
<p><span class="s s194">Of course the ultimate in brevity is to have the program already
written for you, and merely to call it.</span> <span class="s s195">And this brings us to what
I think will be an increasingly important feature of programming
languages: library functions.</span> <span class="s s196">Perl wins because it has large
libraries for manipulating strings.</span> <span class="s s197">This class of library functions
are especially important for throwaway programs, which are often
originally written for converting or extracting data.</span> <span class="s s198">Many Perl
programs probably begin as just a couple library calls stuck
together.</span></p>
<p><span class="s s199">I think a lot of the advances that happen in programming languages
in the next fifty years will have to do with library functions.</span> <span class="s s200">I
think future programming languages will have libraries that are as
carefully designed as the core language.</span> <span class="s s201">Programming language design
will not be about whether to make your language strongly or weakly
typed, or object oriented, or functional, or whatever, but about
how to design great libraries.</span> <span class="s s202">The kind of language designers who
like to think about how to design type systems may shudder at this.</span>
<span class="s s203">It's almost like writing applications!</span> <span class="s s204">Too bad.</span> <span class="s s205">Languages are for
programmers, and libraries are what programmers need.</span></p>
<p><span class="s s206">It's hard to design good libraries.</span> <span class="s s207">It's not simply a matter of
writing a lot of code.</span> <span class="s s208">Once the libraries get too big, it can
sometimes take longer to find the function you need than to write
the code yourself.</span> <span class="s s209">Libraries need to be designed using a small set
of orthogonal operators, just like the core language.</span> <span class="s s210">It ought to
be possible for the programmer to guess what library call will do
what he needs.</span></p>
<p><span class="s s211">Libraries are one place Common Lisp falls short.</span> <span class="s s212">There are only
rudimentary libraries for manipulating strings, and almost none
for talking to the operating system.</span> <span class="s s213">For historical reasons, Common
Lisp tries to pretend that the OS doesn't exist.</span> <span class="s s214">And because you
can't talk to the OS, you're unlikely to be able to write a serious
program using only the built-in operators in Common Lisp.</span> <span class="s s215">You have
to use some implementation-specific hacks as well, and in practice
these tend not to give you everything you want.</span> <span class="s s216">Hackers would think
a lot more highly of Lisp if Common Lisp had powerful string
libraries and good OS support.</span></p>
<p><span class="s s217">7 Syntax</span></p>
<p><span class="s s218">Could a language with Lisp's syntax, or more precisely, lack of
syntax, ever become popular?</span> <span class="s s219">I don't know the answer to this
question.</span> <span class="s s220">I do think that syntax is not the main reason Lisp isn't
currently popular.</span> <span class="s s221">Common Lisp has worse problems than unfamiliar
syntax.</span> <span class="s s222">I know several programmers who are comfortable with prefix
syntax and yet use Perl by default, because it has powerful string
libraries and can talk to the os.</span></p>
<p><span class="s s223">There are two possible problems with prefix notation: that it is
unfamiliar to programmers, and that it is not dense enough.</span> <span class="s s224">The
conventional wisdom in the Lisp world is that the first problem is
the real one.</span> <span class="s s225">I'm not so sure.</span> <span class="s s226">Yes, prefix notation makes ordinary
programmers panic.</span> <span class="s s227">But I don't think ordinary programmers' opinions
matter.</span> <span class="s s228">Languages become popular or unpopular based on what expert
hackers think of them, and I think expert hackers might be able to
deal with prefix notation.</span> <span class="s s229">Perl syntax can be pretty incomprehensible,
but that has not stood in the way of Perl's popularity.</span> <span class="s s230">If anything
it may have helped foster a Perl cult.</span></p>
<p><span class="s s231">A more serious problem is the diffuseness of prefix notation.</span> <span class="s s232">For
expert hackers, that really is a problem.</span> <span class="s s233">No one wants to write
(aref a x y) when they could write a[x,y].</span></p>
<p><span class="s s234">In this particular case there is a way to finesse our way out of
the problem.</span> <span class="s s235">If we treat data structures as if they were functions
on indexes, we could write (a x y) instead, which is even shorter
than the Perl form.</span> <span class="s s236">Similar tricks may shorten other types of
expressions.</span></p>
<p><span class="s s237">We can get rid of (or make optional) a lot of parentheses by making
indentation significant.</span> <span class="s s238">That's how programmers read code anyway:
when indentation says one thing and delimiters say another, we go
by the indentation.</span> <span class="s s239">Treating indentation as significant would
eliminate this common source of bugs as well as making programs
shorter.</span></p>
<p><span class="s s240">Sometimes infix syntax is easier to read.</span> <span class="s s241">This is especially true
for math expressions.</span> <span class="s s242">I've used Lisp my whole programming life and
I still don't find prefix math expressions natural.</span> <span class="s s243">And yet it is
convenient, especially when you're generating code, to have operators
that take any number of arguments.</span> <span class="s s244">So if we do have infix syntax,
it should probably be implemented as some kind of read-macro.</span></p>
<p><span class="s s245">I don't think we should be religiously opposed to introducing syntax
into Lisp, as long as it translates in a well-understood way into
underlying s-expressions.</span> <span class="s s246">There is already a good deal of syntax
in Lisp.</span> <span class="s s247">It's not necessarily bad to introduce more, as long as no
one is forced to use it.</span> <span class="s s248">In Common Lisp, some delimiters are reserved
for the language, suggesting that at least some of the designers
intended to have more syntax in the future.</span></p>
<p><span class="s s249">One of the most egregiously unlispy pieces of syntax in Common Lisp
occurs in format strings; format is a language in its own right,
and that language is not Lisp.</span> <span class="s s250">If there were a plan for introducing
more syntax into Lisp, format specifiers might be able to be included
in it.</span> <span class="s s251">It would be a good thing if macros could generate format
specifiers the way they generate any other kind of code.</span></p>
<p><span class="s s252">An eminent Lisp hacker told me that his copy of CLTL falls open to
the section format.</span> <span class="s s253">Mine too.</span> <span class="s s254">This probably indicates room for
improvement.</span> <span class="s s255">It may also mean that programs do a lot of I/O.</span></p>
<p><span class="s s256">8 Efficiency</span></p>
<p><span class="s s257">A good language, as everyone knows, should generate fast code.</span> <span class="s s258">But
in practice I don't think fast code comes primarily from things
you do in the design of the language.</span> <span class="s s259">As Knuth pointed out long
ago, speed only matters in certain critical bottlenecks.</span> <span class="s s260">And as
many programmers have observed since, one is very often mistaken
about where these bottlenecks are.</span></p>
<p><span class="s s261">So, in practice, the way to get fast code is to have a very good
profiler, rather than by, say, making the language strongly typed.</span>
<span class="s s262">You don't need to know the type of every argument in every call in
the program.</span> <span class="s s263">You do need to be able to declare the types of arguments
in the bottlenecks.</span> <span class="s s264">And even more, you need to be able to find out
where the bottlenecks are.</span></p>
<p><span class="s s265">One complaint people have had with Lisp is that it's hard to tell
what's expensive.</span> <span class="s s266">This might be true.</span> <span class="s s267">It might also be inevitable,
if you want to have a very abstract language.</span> <span class="s s268">And in any case I
think good profiling would go a long way toward fixing the problem:
you'd soon learn what was expensive.</span></p>
<p><span class="s s269">Part of the problem here is social.</span> <span class="s s270">Language designers like to
write fast compilers.</span> <span class="s s271">That's how they measure their skill.</span> <span class="s s272">They
think of the profiler as an add-on, at best.</span> <span class="s s273">But in practice a good
profiler may do more to improve the speed of actual programs written
in the language than a compiler that generates fast code.</span> <span class="s s274">Here,
again, language designers are somewhat out of touch with their
users.</span> <span class="s s275">They do a really good job of solving slightly the wrong
problem.</span></p>
<p><span class="s s276">It might be a good idea to have an active profiler-- to push
performance data to the programmer instead of waiting for him to
come asking for it.</span> <span class="s s277">For example, the editor could display bottlenecks
in red when the programmer edits the source code.</span> <span class="s s278">Another approach
would be to somehow represent what's happening in running programs.
This would be an especially big win in server-based applications,
where you have lots of running programs to look at.</span> <span class="s s279">An active
profiler could show graphically what's happening in memory as a
program's running, or even make sounds that tell what's happening.</span></p>
<p><span class="s s280">Sound is a good cue to problems. In one place I worked, we had a
big board of dials showing what was happening to our web servers.</span>
<span class="s s281">The hands were moved by little servomotors that made a slight noise
when they turned.</span> <span class="s s282">I couldn't see the board from my desk, but I
found that I could tell immediately, by the sound, when there was
a problem with a server.</span></p>
<p><span class="s s283">It might even be possible to write a profiler that would automatically
detect inefficient algorithms. I would not be surprised if certain
patterns of memory access turned out to be sure signs of bad
algorithms. If there were a little guy running around inside the
computer executing our programs, he would probably have as long
and plaintive a tale to tell about his job as a federal government
employee.</span> <span class="s s284">I often have a feeling that I'm sending the processor on
a lot of wild goose chases, but I've never had a good way to look
at what it's doing.</span></p>
<p><span class="s s285">A number of Lisps now compile into byte code, which is then executed
by an interpreter.</span> <span class="s s286">This is usually done to make the implementation
easier to port, but it could be a useful language feature.</span> <span class="s s287">It might
be a good idea to make the byte code an official part of the
language, and to allow programmers to use inline byte code in
bottlenecks.</span> <span class="s s288">Then such optimizations would be portable too.</span></p>
<p><span class="s s289">The nature of speed, as perceived by the end-user, may be changing.</span>
<span class="s s290">With the rise of server-based applications, more and more programs
may turn out to be i/o-bound.</span> <span class="s s291">It will be worth making i/o fast.</span>
<span class="s s292">The language can help with straightforward measures like simple,
fast, formatted output functions, and also with deep structural
changes like caching and persistent objects.</span></p>
<p><span class="s s293">Users are interested in response time.</span> <span class="s s294">But another kind of efficiency
will be increasingly important: the number of simultaneous users
you can support per processor.</span> <span class="s s295">Many of the interesting applications
written in the near future will be server-based, and the number of
users per server is the critical question for anyone hosting such
applications.</span> <span class="s s296">In the capital cost of a business offering a server-based
application, this is the divisor.</span></p>
<p><span class="s s297">For years, efficiency hasn't mattered much in most end-user
applications.</span> <span class="s s298">Developers have been able to assume that each user
would have an increasingly powerful processor sitting on their
desk.</span> <span class="s s299">And by Parkinson's Law, software has expanded to use the
resources available.</span> <span class="s s300">That will change with server-based applications.</span>
<span class="s s301">In that world, the hardware and software will be supplied together.</span>
<span class="s s302">For companies that offer server-based applications, it will make
a very big difference to the bottom line how many users they can
support per server.</span></p>
<p><span class="s s303">In some applications, the processor will be the limiting factor,
and execution speed will be the most important thing to optimize.</span>
<span class="s s304">But often memory will be the limit; the number of simultaneous
users will be determined by the amount of memory you need for each
user's data.</span> <span class="s s305">The language can help here too.</span> <span class="s s306">Good support for
threads will enable all the users to share a single heap.</span> <span class="s s307">It may
also help to have persistent objects and/or language level support
for lazy loading.</span></p>
<p><span class="s s308">9 Time</span></p>
<p><span class="s s309">The last ingredient a popular language needs is time.</span> <span class="s s310">No one wants
to write programs in a language that might go away, as so many
programming languages do.</span> <span class="s s311">So most hackers will tend to wait until
a language has been around for a couple years before even considering
using it.</span></p>
<p><span class="s s312">Inventors of wonderful new things are often surprised to discover
this, but you need time to get any message through to people.</span> <span class="s s313">A
friend of mine rarely does anything the first time someone asks
him.</span> <span class="s s314">He knows that people sometimes ask for things that they turn
out not to want.</span> <span class="s s315">To avoid wasting his time, he waits till the third
or fourth time he's asked to do something; by then, whoever's asking
him may be fairly annoyed, but at least they probably really do
want whatever they're asking for.</span></p>
<p><span class="s s316">Most people have learned to do a similar sort of filtering on new
things they hear about.</span> <span class="s s317">They don't even start paying attention
until they've heard about something ten times.</span> <span class="s s318">They're perfectly
justified: the majority of hot new whatevers do turn out to be a
waste of time, and eventually go away.</span> <span class="s s319">By delaying learning VRML,
I avoided having to learn it at all.</span></p>
<p><span class="s s320">So anyone who invents something new has to expect to keep repeating
their message for years before people will start to get it.</span> <span class="s s321">We
wrote what was, as far as I know, the first web-server based
application, and it took us years to get it through to people that
it didn't have to be downloaded.</span> <span class="s s322">It wasn't that they were stupid.</span>
<span class="s s323">They just had us tuned out.</span></p>
<p><span class="s s324">The good news is, simple repetition solves the problem.</span> <span class="s s325">All you
have to do is keep telling your story, and eventually people will
start to hear.</span> <span class="s s326">It's not when people notice you're there that they
pay attention; it's when they notice you're still there.</span></p>
<p><span class="s s327">It's just as well that it usually takes a while to gain momentum.</span>
<span class="s s328">Most technologies evolve a good deal even after they're first
launched-- programming languages especially.</span> <span class="s s329">Nothing could be better,
for a new techology, than a few years of being used only by a small
number of early adopters.</span> <span class="s s330">Early adopters are sophisticated and
demanding, and quickly flush out whatever flaws remain in your
technology.</span> <span class="s s331">When you only have a few users you can be in close
contact with all of them.</span> <span class="s s332">And early adopters are forgiving when
you improve your system, even if this causes some breakage.</span></p>
<p><span class="s s333">There are two ways new technology gets introduced: the organic
growth method, and the big bang method.</span> <span class="s s334">The organic growth method
is exemplified by the classic seat-of-the-pants underfunded garage
startup.</span> <span class="s s335">A couple guys, working in obscurity, develop some new
technology.</span> <span class="s s336">They launch it with no marketing and initially have
only a few (fanatically devoted) users.</span> <span class="s s337">They continue to improve
the technology, and meanwhile their user base grows by word of
mouth.</span> <span class="s s338">Before they know it, they're big.</span></p>
<p><span class="s s339">The other approach, the big bang method, is exemplified by the
VC-backed, heavily marketed startup.</span> <span class="s s340">They rush to develop a product,
launch it with great publicity, and immediately (they hope) have
a large user base.</span></p>
<p><span class="s s341">Generally, the garage guys envy the big bang guys.</span> <span class="s s342">The big bang
guys are smooth and confident and respected by the VCs.</span> <span class="s s343">They can
afford the best of everything, and the PR campaign surrounding the
launch has the side effect of making them celebrities.</span> <span class="s s344">The organic
growth guys, sitting in their garage, feel poor and unloved.</span> <span class="s s345">And
yet I think they are often mistaken to feel sorry for themselves.</span>
<span class="s s346">Organic growth seems to yield better technology and richer founders
than the big bang method.</span> <span class="s s347">If you look at the dominant technologies
today, you'll find that most of them grew organically.</span></p>
<p><span class="s s348">This pattern doesn't only apply to companies.</span> <span class="s s349">You see it in sponsored
research too.</span> <span class="s s350">Multics and Common Lisp were big-bang projects, and
Unix and MacLisp were organic growth projects.</span></p>
<p><span class="s s351">10 Redesign</span></p>
<p><span class="s s352">"The best writing is rewriting," wrote E.</span> <span class="s s353">B.</span> <span class="s s354">White.</span> <span class="s s355">Every good
writer knows this, and it's true for software too.</span> <span class="s s356">The most important
part of design is redesign.</span> <span class="s s357">Programming languages, especially,
don't get redesigned enough.</span></p>
<p><span class="s s358">To write good software you must simultaneously keep two opposing
ideas in your head.</span> <span class="s s359">You need the young hacker's naive faith in
his abilities, and at the same time the veteran's skepticism.</span> <span class="s s360">You
have to be able to think 
how hard can it be?</span> <span class="s s361">with one half of
your brain while thinking 
it will never work with the other.</span></p>
<p><span class="s s362">The trick is to realize that there's no real contradiction here.</span>
<span class="s s363">You want to be optimistic and skeptical about two different things.</span>
<span class="s s364">You have to be optimistic about the possibility of solving the
problem, but skeptical about the value of whatever solution you've
got so far.</span></p>
<p><span class="s s365">People who do good work often think that whatever they're working
on is no good.</span> <span class="s s366">Others see what they've done and are full of wonder,
but the creator is full of worry.</span> <span class="s s367">This pattern is no coincidence:
it is the worry that made the work good.</span></p>
<p><span class="s s368">If you can keep hope and worry balanced, they will drive a project
forward the same way your two legs drive a bicycle forward.</span> <span class="s s369">In the
first phase of the two-cycle innovation engine, you work furiously
on some problem, inspired by your confidence that you'll be able
to solve it.</span> <span class="s s370">In the second phase, you look at what you've done in
the cold light of morning, and see all its flaws very clearly.</span> <span class="s s371">But
as long as your critical spirit doesn't outweigh your hope, you'll
be able to look at your admittedly incomplete system, and think,
how hard can it be to get the rest of the way?</span><span class="s s372">, thereby continuing
the cycle.</span></p>
<p><span class="s s373">It's tricky to keep the two forces balanced.</span> <span class="s s374">In young hackers,
optimism predominates.</span> <span class="s s375">They produce something, are convinced it's
great, and never improve it.</span> <span class="s s376">In old hackers, skepticism predominates,
and they won't even dare to take on ambitious projects.</span></p>
<p><span class="s s377">Anything you can do to keep the redesign cycle going is good.</span> <span class="s s378">Prose
can be rewritten over and over until you're happy with it.</span> <span class="s s379">But
software, as a rule, doesn't get redesigned enough.</span> <span class="s s380">Prose has
readers, but software has users.</span> <span class="s s381">If a writer rewrites an essay,
people who read the old version are unlikely to complain that their
thoughts have been broken by some newly introduced incompatibility.</span></p>
<p><span class="s s382">Users are a double-edged sword.</span> <span class="s s383">They can help you improve your
language, but they can also deter you from improving it.</span> <span class="s s384">So choose
your users carefully, and be slow to grow their number.</span> <span class="s s385">Having
users is like optimization: the wise course is to delay it.</span> <span class="s s386">Also,
as a general rule, you can at any given time get away with changing
more than you think.</span> <span class="s s387">Introducing change is like pulling off a
bandage: the pain is a memory almost as soon as you feel it.</span></p>
<p><span class="s s388">Everyone knows that it's not a good idea to have a language designed
by a committee.</span> <span class="s s389">Committees yield bad design.</span> <span class="s s390">But I think the worst
danger of committees is that they interfere with redesign.</span> <span class="s s391">It is
so much work to introduce changes that no one wants to bother.</span>
<span class="s s392">Whatever a committee decides tends to stay that way, even if most
of the members don't like it.</span></p>
<p><span class="s s393">Even a committee of two gets in the way of redesign.</span> <span class="s s394">This happens
particularly in the interfaces between pieces of software written
by two different people.</span> <span class="s s395">To change the interface both have to agree
to change it at once.</span> <span class="s s396">And so interfaces tend not to change at all,
which is a problem because they tend to be one of the most ad hoc
parts of any system.</span></p>
<p><span class="s s397">One solution here might be to design systems so that interfaces
are horizontal instead of vertical-- so that modules are always
vertically stacked strata of abstraction.</span> <span class="s s398">Then the interface will
tend to be owned by one of them.</span> <span class="s s399">The lower of two levels will either
be a language in which the upper is written, in which case the
lower level will own the interface, or it will be a slave, in which
case the interface can be dictated by the upper level.</span></p>
<p><span class="s s400">11 Lisp</span></p>
<p><span class="s s401">What all this implies is that there is hope for a new Lisp.</span> <span class="s s402">There
is hope for any language that gives hackers what they want, including
Lisp.</span> <span class="s s403">I think we may have made a mistake in thinking that hackers
are turned off by Lisp's strangeness.</span> <span class="s s404">This comforting illusion may
have prevented us from seeing the real problem with Lisp, or at
least Common Lisp, which is that it sucks for doing what hackers
want to do.</span> <span class="s s405">A hacker's language needs powerful libraries and
something to hack.</span> <span class="s s406">Common Lisp has neither.</span> <span class="s s407">A hacker's language is
terse and hackable.</span> <span class="s s408">Common Lisp is not.</span></p>
<p><span class="s s409">The good news is, it's not Lisp that sucks, but Common Lisp.</span> <span class="s s410">If we
can develop a new Lisp that is a real hacker's language, I think
hackers will use it.</span> <span class="s s411">They will use whatever language does the job.</span>
<span class="s s412">All we have to do is make sure this new Lisp does some important
job better than other languages.</span></p>
<p><span class="s s413">History offers some encouragement.</span> <span class="s s414">Over time, successive new
programming languages have taken more and more features from Lisp.</span>
<span class="s s415">There is no longer much left to copy before the language you've
made is Lisp.</span> <span class="s s416">The latest hot language, Python, is a watered-down
Lisp with infix syntax and no macros.</span> <span class="s s417">A new Lisp would be a natural
step in this progression.</span></p>
<p><span class="s s418">I sometimes think that it would be a good marketing trick to call
it an improved version of Python.</span> <span class="s s419">That sounds hipper than Lisp.</span> <span class="s s420">To
many people, Lisp is a slow AI language with a lot of parentheses.</span>
<span class="s s421">Fritz Kunze's official biography carefully avoids mentioning the
L-word.</span> <span class="s s422">But my guess is that we shouldn't be afraid to call the
new Lisp Lisp.</span> <span class="s s423">Lisp still has a lot of latent respect among the
very best hackers-- the ones who took 6.</span><span class="s s424">001 and understood it, for
example.</span> <span class="s s425">And those are the users you need to win.</span></p>
<p><span class="s s426">In "How to Become a Hacker," Eric Raymond describes Lisp as something
like Latin or Greek-- a language you should learn as an intellectual
exercise, even though you won't actually use it:</span>
</p><span class="s s427">&nbsp;
 Lisp is worth learning for the profound enlightenment experience
 you will have when you finally get it; that experience will make
 you a better programmer for the rest of your days, even if you
 never actually use Lisp itself a lot.
&nbsp;
If I didn't know Lisp, reading this would set me asking questions.
A language that would make me a better programmer, if it means
anything at all, means a language that would be better for programming.
And that is in fact the implication of what Eric is saying.</span><p><span class="s s428">As long as that idea is still floating around, I think hackers will
be receptive enough to a new Lisp, even if it is called Lisp.</span> <span class="s s429">But
this Lisp must be a hacker's language, like the classic Lisps of
the 1970s.</span> <span class="s s430">It must be terse, simple, and hackable.</span> <span class="s s431">And it must have
powerful libraries for doing what hackers want to do now.</span></p>
<p><span class="s s432">In the matter of libraries I think there is room to beat languages
like Perl and Python at their own game.</span> <span class="s s433">A lot of the new applications
that will need to be written in the coming years will be 
server-based
applications.</span> <span class="s s434">There's no reason a new Lisp shouldn't have string
libraries as good as Perl, and if this new Lisp also had powerful
libraries for server-based applications, it could be very popular.</span>
<span class="s s435">Real hackers won't turn up their noses at a new tool that will let
them solve hard problems with a few library calls.</span> <span class="s s436">Remember, hackers
are lazy.</span></p>
<p><span class="s s437">It could be an even bigger win to have core language support for
server-based applications.</span> <span class="s s438">For example, explicit support for programs
with multiple users, or data ownership at the level of type tags.</span></p>
<p><span class="s s439">Server-based applications also give us the answer to the question
of what this new Lisp will be used to hack.</span> <span class="s s440">It would not hurt to
make Lisp better as a scripting language for Unix.</span> <span class="s s441">(It would be
hard to make it worse.</span><span class="s s442">) But I think there are areas where existing
languages would be easier to beat.</span> <span class="s s443">I think it might be better to
follow the model of Tcl, and supply the Lisp together with a complete
system for supporting server-based applications.</span> <span class="s s444">Lisp is a natural
fit for server-based applications.</span> <span class="s s445">Lexical closures provide a way
to get the effect of subroutines when the ui is just a series of
web pages.</span> <span class="s s446">S-expressions map nicely onto html, and macros are good
at generating it.</span> <span class="s s447">There need to be better tools for writing
server-based applications, and there needs to be a new Lisp, and
the two would work very well together.</span></p>
<p><span class="s s448">12 The Dream Language</span></p>
<p><span class="s s449">By way of summary, let's try describing the hacker's dream language.</span>
<span class="s s450">The dream language is 
beautiful, clean, and terse.</span> <span class="s s451">It has an
interactive toplevel that starts up fast.</span> <span class="s s452">You can write programs
to solve common problems with very little code.</span> <span class="s s453">Nearly all the
code in any program you write is code that's specific to your
application.</span> <span class="s s454">Everything else has been done for you.</span></p>
<p><span class="s s455">The syntax of the language is brief to a fault. You never have to
type an unnecessary character, or even to use the shift key much.</span></p>
<p><span class="s s456">Using big abstractions you can write the first version of a program
very quickly.</span> <span class="s s457">Later, when you want to optimize, there's a really
good profiler that tells you where to focus your attention.</span> <span class="s s458">You
can make inner loops blindingly fast, even writing inline byte code
if you need to.</span></p>
<p><span class="s s459">There are lots of good examples to learn from, and the language is
intuitive enough that you can learn how to use it from examples in
a couple minutes.</span> <span class="s s460">You don't need to look in the manual much.</span> <span class="s s461">The
manual is thin, and has few warnings and qualifications.</span></p>
<p><span class="s s462">The language has a small core, and powerful, highly orthogonal
libraries that are as carefully designed as the core language.</span> <span class="s s463">The
libraries all work well together; everything in the language fits
together like the parts in a fine camera.</span> <span class="s s464">Nothing is deprecated,
or retained for compatibility.</span> <span class="s s465">The source code of all the libraries
is readily available.</span> <span class="s s466">It's easy to talk to the operating system
and to applications written in other languages.</span></p>
<p><span class="s s467">The language is built in layers.</span> <span class="s s468">The higher-level abstractions are
built in a very transparent way out of lower-level abstractions,
which you can get hold of if you want.</span></p>
<p><span class="s s469">Nothing is hidden from you that doesn't absolutely have to be.</span> <span class="s s470">The
language offers abstractions only as a way of saving you work,
rather than as a way of telling you what to do.</span> <span class="s s471">In fact, the language
encourages you to be an equal participant in its design.</span> <span class="s s472">You can
change everything about it, including even its syntax, and anything
you write has, as much as possible, the same status as what comes
predefined.</span></p>
<p><span class="s s473">Notes</span></p>
<p><span class="s s474">[1] Macros very close to the modern idea were proposed by Timothy
Hart in 1964, two years after Lisp 1.</span><span class="s s475">5 was released.</span> <span class="s s476">What was
missing, initially, were ways to avoid variable capture and multiple
evaluation; Hart's examples are subject to both.</span></p>
<p><span class="s s477">[2] In When the Air Hits Your Brain, neurosurgeon Frank Vertosick
recounts a conversation in which his chief resident, Gary, talks
about the difference between surgeons and internists ("fleas"):</span>
</p><span class="s s478">&nbsp;
 Gary and I ordered a large pizza and found an open booth. The
 chief lit a cigarette. "Look at those goddamn fleas, jabbering
 about some disease they'll see once in their lifetimes. That's
 the trouble with fleas, they only like the bizarre stuff. They
 hate their bread and butter cases. That's the difference between
 us and the fucking fleas. See, we love big juicy lumbar disc
 herniations, but they hate hypertension...."
&nbsp;
It's hard to think of a lumbar disc herniation as juicy (except
literally). And yet I think I know what they mean. I've often had
a juicy bug to track down. Someone who's not a programmer would
find it hard to imagine that there could be pleasure in a bug.
Surely it's better if everything just works. In one way, it is.
And yet there is undeniably a grim satisfaction in hunting down
certain sorts of bugs.</span></div></div>
  </body></html>
